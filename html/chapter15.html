<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第15章：近存储计算架构</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">芯片互联与封装技术教程</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：NoC架构概述</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：路由算法与流控</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：NoC性能建模与优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：2.5D封装技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：3D封装与异构集成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：Chiplet设计理念与经济学</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：Die-to-Die接口标准</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：Chiplet物理层设计</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：Chiplet系统架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：Chiplet集成与验证</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：HBM架构基础</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：HBM物理实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：HBM系统设计</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：HBM编程模型与软件栈</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：近存储计算架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：CXL与内存扩展</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第17章：数据中心规模互联</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第18章：AI加速器互联</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第19章：移动与边缘芯片互联</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第20章：AMD Infinity架构演进</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第21章：光电混合互联</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第22章：量子互联初探</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="15">第15章：近存储计算架构</h1>
<h2 id="_1">章节概述</h2>
<p>本章深入探讨近存储计算（Processing-in-Memory, PIM）和近数据处理（Processing-near-Data, PND）架构，这是解决"内存墙"问题的革命性方案。我们将分析如何通过将计算单元集成到内存系统中，大幅减少数据移动开销，提升系统能效比。重点介绍Samsung HBM-PIM、SK Hynix AiM等工业界先进实现，以及在AI推理、图计算等应用中的实践。</p>
<p><strong>学习目标：</strong></p>
<ul>
<li>理解PIM架构的基本原理和设计权衡</li>
<li>掌握HBM-PIM的实现细节和编程模型</li>
<li>分析内存一致性和软件栈挑战</li>
<li>评估PIM在不同应用场景下的性能收益</li>
</ul>
<h2 id="151-pim">15.1 PIM概念与发展历程</h2>
<h3 id="1511">15.1.1 内存墙问题的本质</h3>
<p>过去几十年，处理器性能以每年约60%的速度增长，而DRAM访问延迟仅以每年7%的速度改善。这种差距导致了严重的"内存墙"问题：</p>
<div class="codehilite"><pre><span></span><code>性能差距 = (1.6)^n / (1.07)^n ≈ (1.5)^n
其中n为年数
</code></pre></div>

<p>数据移动能耗已成为系统功耗的主要来源：</p>
<ul>
<li>32位浮点运算：约20pJ</li>
<li>从DRAM读取32位数据：约640pJ</li>
<li>数据移动能耗是计算的32倍</li>
</ul>
<h3 id="1512-pim">15.1.2 PIM架构分类</h3>
<ol>
<li><strong>真PIM（True PIM）</strong>
将逻辑单元直接集成在存储阵列内部：</li>
</ol>
<div class="codehilite"><pre><span></span><code>  ┌──────────────────────────┐
  │   Memory Array           │
  │  ┌────┬────┬────┬────┐  │
  │  │Cell│Cell│Cell│Cell│  │
  │  ├────┼────┼────┼────┤  │
  │  │ ALU│ ALU│ ALU│ ALU│  │ ← 计算单元
  │  ├────┼────┼────┼────┤  │
  │  │Cell│Cell│Cell│Cell│  │
  │  └────┴────┴────┴────┘  │
  │       Sense Amplifiers   │
  └──────────────────────────┘
</code></pre></div>

<ol start="2">
<li><strong>近数据处理（PND）</strong>
在内存控制器或基础逻辑层集成计算单元：</li>
</ol>
<div class="codehilite"><pre><span></span><code>  ┌──────────────────────────┐
  │   DRAM Die Stack         │
  ├──────────────────────────┤
  │   Through Silicon Vias   │
  ├──────────────────────────┤
  │   Logic Base Die         │ ← 计算层
  │  ┌─────────────────────┐ │
  │  │ Processing Units    │ │
  │  │ Cache &amp; Controllers │ │
  │  └─────────────────────┘ │
  └──────────────────────────┘
</code></pre></div>

<h3 id="1513-pim">15.1.3 PIM发展历程</h3>
<p><strong>第一代（1990s）：</strong></p>
<ul>
<li>Computational RAM (C-RAM)</li>
<li>简单的位运算</li>
<li>制造工艺限制</li>
</ul>
<p><strong>第二代（2000s）：</strong></p>
<ul>
<li>Active Memory</li>
<li>SIMD处理器集成</li>
<li>功耗密度问题</li>
</ul>
<p><strong>第三代（2010s-至今）：</strong></p>
<ul>
<li>3D堆叠技术成熟</li>
<li>HBM-PIM商用化</li>
<li>AI加速驱动</li>
</ul>
<h2 id="152-samsung-hbm-pim">15.2 Samsung HBM-PIM架构详解</h2>
<h3 id="1521">15.2.1 系统架构</h3>
<p>Samsung HBM-PIM在HBM2 Aquabolt基础上，在每个伪通道（Pseudo Channel）集成了一个SIMD处理单元：</p>
<div class="codehilite"><pre><span></span><code>  ┌─────────────────────────────────────┐
  │         Host Processor              │
  ├─────────────────────────────────────┤
  │         Memory Controller           │
  └────────┬───────────────────┬────────┘
           │   1024-bit Bus    │
  ┌────────▼───────────────────▼────────┐
  │           HBM-PIM Stack              │
  │  ┌──────────────────────────────┐   │
  │  │    DRAM Die 7 (4GB)          │   │
  │  ├──────────────────────────────┤   │
  │  │    DRAM Die 6 (4GB)          │   │
  │  ├──────────────────────────────┤   │
  │  │    ...                       │   │
  │  ├──────────────────────────────┤   │
  │  │    DRAM Die 0 (4GB)          │   │
  │  ├──────────────────────────────┤   │
  │  │    Buffer/Logic Die          │   │
  │  │  ┌────────────────────────┐  │   │
  │  │  │  16 × PIM Units        │  │   │
  │  │  │  (2 per PC)            │  │   │
  │  │  └────────────────────────┘  │   │
  │  └──────────────────────────────┘   │
  └─────────────────────────────────────┘
</code></pre></div>

<h3 id="1522-pim">15.2.2 PIM单元微架构</h3>
<p>每个PIM单元包含：</p>
<ul>
<li><strong>可编程计算单元（PCU）</strong>：支持FP16运算</li>
<li><strong>单指令多数据（SIMD）引擎</strong>：16-wide向量处理</li>
<li><strong>本地寄存器文件</strong>：8个通用寄存器</li>
<li><strong>指令缓冲器</strong>：存储PIM指令序列</li>
</ul>
<div class="codehilite"><pre><span></span><code>PIM Unit微架构：
  ┌─────────────────────────────────┐
  │         To Memory Banks         │
  └────────────┬────────────────────┘
               │ 256-bit
  ┌────────────▼────────────────────┐
  │      Data Buffer (2KB)          │
  ├─────────────────────────────────┤
  │   ┌─────────┐  ┌─────────┐     │
  │   │  FP16   │  │  INT8   │     │
  │   │  MAC    │  │  ALU    │     │
  │   └────┬────┘  └────┬────┘     │
  │        │            │           │
  │   ┌────▼────────────▼────┐     │
  │   │  Register File (8×)   │     │
  │   └───────────────────────┘     │
  ├─────────────────────────────────┤
  │    Instruction Buffer           │
  └─────────────────────────────────┘
</code></pre></div>

<h3 id="1523">15.2.3 性能特征</h3>
<p><strong>计算能力：</strong></p>
<ul>
<li>1.2 TFLOPS (FP16) @ 1.2GHz</li>
<li>功耗效率：1.38 TFLOPS/W</li>
<li>相比GPU内存访问：功耗降低71%</li>
</ul>
<p><strong>带宽利用：</strong></p>
<div class="codehilite"><pre><span></span><code>内部带宽 = 16 channels × 128-bit × 2 (DDR) × 1.2GHz
        = 16 × 128 × 2 × 1.2 × 10^9 / 8
        = 614.4 GB/s (per stack)
</code></pre></div>

<h2 id="153">15.3 逻辑层设计与计算单元实现</h2>
<h3 id="1531">15.3.1 逻辑层物理设计</h3>
<p>HBM-PIM的逻辑层必须在有限的面积和功耗预算内实现高效计算：</p>
<p><strong>面积约束：</strong></p>
<ul>
<li>总面积：约100mm²</li>
<li>PIM单元面积：约1.5mm²/unit</li>
<li>TSV阵列占用：约20%面积</li>
</ul>
<p><strong>功耗预算：</strong></p>
<div class="codehilite"><pre><span></span><code>总功耗预算 = 15W (典型HBM功耗)
PIM计算功耗 = 5W
内存访问功耗 = 8W
IO功耗 = 2W
</code></pre></div>

<h3 id="1532">15.3.2 计算单元设计权衡</h3>
<ol>
<li><strong>SIMD宽度选择</strong></li>
</ol>
<p>宽度选择影响性能和面积：</p>
<div class="codehilite"><pre><span></span><code>性能 ∝ SIMD_width × 频率
面积 ∝ SIMD_width × log(SIMD_width)  // 考虑互联复杂度
</code></pre></div>

<p>Samsung选择16-wide SIMD的原因：</p>
<ul>
<li>匹配内存行缓冲器宽度（2KB）</li>
<li>平衡计算吞吐量和内存带宽</li>
<li>适合AI推理工作负载</li>
</ul>
<ol start="2">
<li><strong>数据精度支持</strong></li>
</ol>
<p>支持多种精度的权衡：</p>
<ul>
<li>FP16：AI训练标准精度</li>
<li>INT8：推理量化格式</li>
<li>BF16：兼容性考虑</li>
</ul>
<div class="codehilite"><pre><span></span><code>面积开销比例：
FP16 MAC: 1.0×
INT8 MAC: 0.3×
BF16 MAC: 0.8×
混合精度: 1.5× (支持全部)
</code></pre></div>

<h3 id="1533">15.3.3 内存访问模式优化</h3>
<p>PIM架构支持三种访问模式：</p>
<ol>
<li><strong>批处理模式（Batch Mode）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">batches</span><span class="p">:</span>
<span class="w">    </span><span class="n">load_weights_to_pim</span><span class="p">()</span><span class="w">      </span><span class="o">//</span><span class="w"> </span><span class="err">一次加载</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">batch</span><span class="p">:</span>
<span class="w">        </span><span class="n">compute_in_pim</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="err">多次复用</span>
<span class="w">    </span><span class="n">store_results</span><span class="p">()</span>
</code></pre></div>

<ol start="2">
<li><strong>流式处理模式（Streaming Mode）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>while (data_available):
    fetch_next_block()          // 流水线取数
    process_in_pim()            // 并行计算
    write_back_results()        // 异步写回
</code></pre></div>

<ol start="3">
<li><strong>分块计算模式（Tiled Mode）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>将大矩阵分块以适应PIM容量：
Matrix_size = M × N
Tile_size = m × n (受限于local buffer)
Tiles = ⌈M/m⌉ × ⌈N/n⌉
</code></pre></div>

<h2 id="154">15.4 编程模型与软件栈</h2>
<h3 id="1541-pim">15.4.1 PIM编程抽象</h3>
<ol>
<li><strong>指令集架构（ISA）</strong></li>
</ol>
<p>PIM-ISA包含以下指令类型：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 数据移动指令</span>
<span class="nx">PIM_LOAD</span><span class="w">  </span><span class="nx">reg</span><span class="p">,</span><span class="w"> </span><span class="nx">mem_addr</span><span class="w">     </span><span class="c1">// 从DRAM加载到寄存器</span>
<span class="nx">PIM_STORE</span><span class="w"> </span><span class="nx">mem_addr</span><span class="p">,</span><span class="w"> </span><span class="nx">reg</span><span class="w">     </span><span class="c1">// 从寄存器存储到DRAM</span>

<span class="c1">// 计算指令</span>
<span class="nx">PIM_MAC</span><span class="w">   </span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">src1</span><span class="p">,</span><span class="w"> </span><span class="nx">src2</span><span class="w">   </span><span class="c1">// 乘累加操作</span>
<span class="nx">PIM_ADD</span><span class="w">   </span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">src1</span><span class="p">,</span><span class="w"> </span><span class="nx">src2</span><span class="w">   </span><span class="c1">// 向量加法</span>
<span class="nx">PIM_MUL</span><span class="w">   </span><span class="nx">dst</span><span class="p">,</span><span class="w"> </span><span class="nx">src1</span><span class="p">,</span><span class="w"> </span><span class="nx">src2</span><span class="w">   </span><span class="c1">// 向量乘法</span>

<span class="c1">// 控制指令</span>
<span class="nx">PIM_SYNC</span><span class="w">                     </span><span class="c1">// 同步屏障</span>
<span class="nx">PIM_FENCE</span><span class="w">                    </span><span class="c1">// 内存屏障</span>
</code></pre></div>

<ol start="2">
<li><strong>编程接口</strong></li>
</ol>
<p>高级API示例：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// C++ API示例</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PIMTensor</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">gemm</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PIMTensor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PIMTensor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 自动分块和调度到PIM单元</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">tiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tiles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">schedule_to_pim</span><span class="p">(</span><span class="n">tile</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">synchronize</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="1542">15.4.2 编译器支持</h3>
<p>PIM编译器需要解决的关键问题：</p>
<ol>
<li><strong>计算映射</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">原始代码</span><span class="err">：</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="n">C</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>

<span class="n">PIM优化后</span><span class="err">：</span>
<span class="n">parallel_for</span><span class="w"> </span><span class="n">pim_unit</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="o">[</span><span class="n">0..15</span><span class="o">]</span><span class="err">:</span>
<span class="w">    </span><span class="n">local_M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">16</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">local_M</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">pim_mac</span><span class="p">(</span><span class="n">C</span><span class="o">[</span><span class="n">pim_unit</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span>
</code></pre></div>

<ol start="2">
<li><strong>数据布局优化</strong></li>
</ol>
<p>优化内存布局以最大化PIM并行性：</p>
<div class="codehilite"><pre><span></span><code><span class="n">传统行主序</span><span class="err">：</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">memory</span><span class="o">[</span><span class="n">i*N + j</span><span class="o">]</span>
<span class="n">PIM优化布局</span><span class="err">：</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">memory</span><span class="o">[</span><span class="n">channel</span><span class="o">][</span><span class="n">bank</span><span class="o">][</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span>
<span class="w">              </span><span class="n">其中channel映射到PIM单元</span>
</code></pre></div>

<h3 id="1543">15.4.3 运行时系统</h3>
<ol>
<li><strong>任务调度器</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PIMScheduler</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">queue</span><span class="o">&lt;</span><span class="n">PIMTask</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ready_queue</span><span class="p">;</span>
<span class="w">    </span><span class="n">array</span><span class="o">&lt;</span><span class="n">PIMUnit</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pim_units</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">schedule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ready_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ready_queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_idle_unit</span><span class="p">();</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">dispatch</span><span class="p">(</span><span class="n">task</span><span class="p">,</span><span class="w"> </span><span class="n">unit</span><span class="p">);</span>
<span class="w">                </span><span class="n">ready_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<ol start="2">
<li><strong>内存管理</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PIMMemoryManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 维护PIM可访问内存池</span>
<span class="w">    </span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PIMMemoryRegion</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pim_regions</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">allocate_pim_memory</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 分配在PIM可访问的地址范围</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_free_region</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="n">mark_as_pim_accessible</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">region</span><span class="p">.</span><span class="n">base_addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="155">15.5 应用场景分析</h2>
<h3 id="1551-ai">15.5.1 AI推理加速</h3>
<ol>
<li><strong>BERT推理优化</strong></li>
</ol>
<p>BERT-Base模型参数：</p>
<ul>
<li>12层Transformer</li>
<li>768维隐藏层</li>
<li>110M参数</li>
</ul>
<p>PIM加速关键操作：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Attention计算</span>
<span class="n">Q</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Input</span><span class="w"> </span>×<span class="w"> </span><span class="n">W_q</span><span class="w">  </span><span class="c1">// 适合PIM</span>
<span class="n">K</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Input</span><span class="w"> </span>×<span class="w"> </span><span class="n">W_k</span><span class="w">  </span><span class="c1">// 适合PIM</span>
<span class="n">V</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Input</span><span class="w"> </span>×<span class="w"> </span><span class="n">W_v</span><span class="w">  </span><span class="c1">// 适合PIM</span>
<span class="n">Attention</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">softmax</span><span class="p">(</span><span class="n">Q</span><span class="w"> </span>×<span class="w"> </span><span class="n">K</span>^<span class="n">T</span><span class="p">)</span><span class="w"> </span>×<span class="w"> </span><span class="n">V</span>

性能提升：

<span class="o">-</span><span class="w"> </span>矩阵乘法：<span class="mf">2.7</span>×
<span class="o">-</span><span class="w"> </span>整体推理：<span class="mf">1.8</span>×
<span class="o">-</span><span class="w"> </span>能效比：<span class="mf">2.2</span>×
</code></pre></div>

<ol start="2">
<li><strong>CNN推理优化</strong></li>
</ol>
<p>ResNet-50在ImageNet上的推理：</p>
<div class="codehilite"><pre><span></span><code>卷积层计算密度：
FLOPS/Byte = (K × K × C_in) / (K × K × C_in × 4 + C_out × 4)
           ≈ 0.25 (低算术强度，适合PIM)

PIM优化策略：

<span class="k">-</span> 权重驻留在PIM本地
<span class="k">-</span> 输入特征图流式处理
<span class="k">-</span> 部分和在PIM内累加
</code></pre></div>

<h3 id="1552">15.5.2 图计算加速</h3>
<ol>
<li><strong>PageRank算法</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">传统实现伪代码</span><span class="err">：</span>
<span class="k">for</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">vertices</span><span class="p">:</span>
<span class="w">        </span><span class="nf">rank</span><span class="o">[</span><span class="n">v</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.15</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.85</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="nf">rank</span><span class="o">[</span><span class="n">u</span><span class="o">]/</span><span class="n">out_degree</span><span class="o">[</span><span class="n">u</span><span class="o">]</span><span class="w"> </span>
<span class="w">                                    </span><span class="k">for</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">predecessors</span><span class="o">[</span><span class="n">v</span><span class="o">]</span><span class="p">)</span>

<span class="n">PIM优化</span><span class="err">：</span>

<span class="o">-</span><span class="w"> </span><span class="n">邻接表存储在PIM本地</span>
<span class="o">-</span><span class="w"> </span><span class="n">并行更新多个顶点</span>
<span class="o">-</span><span class="w"> </span><span class="n">减少随机访问开销</span>

<span class="n">性能提升</span><span class="err">：</span><span class="mf">3.2</span><span class="err">×</span><span class="w"> </span><span class="p">(</span><span class="n">对于大规模稀疏图</span><span class="p">)</span>
</code></pre></div>

<ol start="2">
<li><strong>图神经网络（GNN）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>GCN前向传播：
H^(l+1) = σ(D^(-1/2) × A × D^(-1/2) × H^(l) × W^(l))

PIM优化点：

- 稀疏矩阵乘法
- 特征聚合操作
- 邻居采样

加速比：2.5-4.0× (取决于图稀疏度)
</code></pre></div>

<h3 id="1553">15.5.3 科学计算应用</h3>
<p><strong>稀疏矩阵求解器</strong></p>
<div class="codehilite"><pre><span></span><code>SpMV操作（y = A × x）：
传统实现内存访问模式：

- 不规则访问x向量
- 顺序访问A的非零元素

PIM优化：

- x向量分布存储
- 本地计算部分结果
- 减少全局归约

性能提升矩阵：
矩阵类型        加速比
带状矩阵        1.5×
随机稀疏        2.8×
幂律分布        3.5×
</code></pre></div>

<h2 id="156">15.6 内存一致性挑战</h2>
<h3 id="1561">15.6.1 一致性模型设计</h3>
<p>PIM系统需要解决的一致性问题：</p>
<ol>
<li><strong>PIM与主处理器的一致性</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>场景：CPU和PIM同时访问相同数据
解决方案：

- 弱一致性模型 + 显式同步
- 基于区域的一致性协议
- 版本化内存管理
</code></pre></div>

<ol start="2">
<li><strong>多PIM单元间的一致性</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>   CPU
    │
    ├──────┬──────┬──────┐
    │      │      │      │
  PIM0   PIM1   PIM2   PIM3
    │      │      │      │
    └──────┴──────┴──────┘
         Coherence Bus

协议选择：

- 基于目录的协议（开销大）
- 基于令牌的协议（延迟高）
- 软件管理一致性（灵活性高）
</code></pre></div>

<h3 id="1562">15.6.2 数据一致性保证机制</h3>
<ol>
<li><strong>内存围栏（Memory Fence）</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// PIM操作前后的围栏</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">pim_compute_safe</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">memory_fence</span><span class="p">();</span><span class="w">           </span><span class="c1">// 确保之前的写入完成</span>
<span class="w">    </span><span class="n">pim_execute</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">  </span><span class="c1">// PIM计算</span>
<span class="w">    </span><span class="n">memory_fence</span><span class="p">();</span><span class="w">           </span><span class="c1">// 确保PIM结果可见</span>
<span class="p">}</span>
</code></pre></div>

<ol start="2">
<li><strong>原子操作支持</strong></li>
</ol>
<div class="codehilite"><pre><span></span><code>PIM原子操作实现：

- Compare-and-Swap (CAS)
- Fetch-and-Add
- 原子归约操作

硬件支持：

- 锁定内存行
- 事务内存扩展
- 版本缓冲区
</code></pre></div>

<h3 id="1563">15.6.3 虚拟内存集成</h3>
<p><strong>地址转换挑战：</strong></p>
<div class="codehilite"><pre><span></span><code>传统TLB无法支持PIM访问模式
解决方案：

1. PIM-TLB设计
   - 更大的页面（2MB/1GB）
   - 预取机制
   - 共享TLB结构

2. 段式内存管理
   - 连续物理内存分配
   - 减少转换开销
</code></pre></div>

<h2 id="157-sk-hynix-aim">15.7 案例研究：SK Hynix AiM技术</h2>
<h3 id="1571-aim">15.7.1 AiM架构创新</h3>
<p>SK Hynix的AiM（Accelerator in Memory）采用了不同于Samsung的设计理念：</p>
<div class="codehilite"><pre><span></span><code>AiM-HBM架构：
┌────────────────────────────────┐
│      GDDR6 Interface           │
├────────────────────────────────┤
│   AI Processing Unit (APU)     │
│  ┌───────────────────────────┐ │
│  │  512 RISC-V Cores        │ │
│  │  @ 1.25 GHz               │ │
│  └───────────────────────────┘ │
├────────────────────────────────┤
│      16GB HBM3 Stack           │
└────────────────────────────────┘

关键特性：

- 512个RISC-V核心
- 1.25 GHz运行频率
- 16 TFLOPS (FP16)
- 1.2 TB/s内部带宽
</code></pre></div>

<h3 id="1572">15.7.2 编程模型对比</h3>
<p><strong>AiM编程特点：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 基于数据流的编程模型</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AiMKernel</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">execute</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 自动数据分区</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">partitions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_flow_partition</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 并行执行在512个核心上</span>
<span class="w">        </span><span class="n">parallel_for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">partitions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">local_compute</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 硬件加速的归约</span>
<span class="w">        </span><span class="n">hardware_reduce</span><span class="p">(</span><span class="n">partitions</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="1573">15.7.3 性能评估</h3>
<p><strong>基准测试结果对比：</strong></p>
<p>| 工作负载 | Samsung HBM-PIM | SK Hynix AiM | 传统GPU+HBM |</p>
<table>
<thead>
<tr>
<th>工作负载</th>
<th>Samsung HBM-PIM</th>
<th>SK Hynix AiM</th>
<th>传统GPU+HBM</th>
</tr>
</thead>
<tbody>
<tr>
<td>GEMM</td>
<td>1.0×</td>
<td>1.8×</td>
<td>0.5×</td>
</tr>
<tr>
<td>SpMV</td>
<td>2.3×</td>
<td>2.1×</td>
<td>1.0×</td>
</tr>
<tr>
<td>BERT</td>
<td>1.8×</td>
<td>2.2×</td>
<td>1.0×</td>
</tr>
<tr>
<td>GCN</td>
<td>2.5×</td>
<td>3.1×</td>
<td>1.0×</td>
</tr>
<tr>
<td>功耗</td>
<td>35W</td>
<td>40W</td>
<td>150W</td>
</tr>
</tbody>
</table>
<h3 id="1574">15.7.4 应用生态系统</h3>
<p>SK Hynix AiM的软件栈：</p>
<div class="codehilite"><pre><span></span><code>应用层：     TensorFlow | PyTorch | ONNX
           ─────────────────────────────
框架层：     AiM Runtime API
           ─────────────────────────────
编译器：     MLIR-based Compiler
           ─────────────────────────────
驱动层：     AiM Device Driver
           ─────────────────────────────
硬件层：     AiM-HBM Hardware
</code></pre></div>

<h2 id="158">15.8 未来发展趋势</h2>
<h3 id="1581">15.8.1 技术演进路线</h3>
<p><strong>第四代PIM预期特性：</strong></p>
<ul>
<li>7nm/5nm逻辑工艺</li>
<li>支持稀疏计算</li>
<li>可重构架构</li>
<li>光互联集成</li>
</ul>
<p><strong>性能目标（2025-2027）：</strong></p>
<div class="codehilite"><pre><span></span><code>计算密度：100 TFLOPS/stack
能效比：10 TFLOPS/W
内存容量：64GB/stack
带宽：2 TB/s
</code></pre></div>

<h3 id="1582">15.8.2 标准化进展</h3>
<p><strong>JEDEC PIM标准化：</strong></p>
<ul>
<li>统一编程接口</li>
<li>标准指令集</li>
<li>一致性协议</li>
<li>测试规范</li>
</ul>
<h3 id="1583">15.8.3 新兴应用领域</h3>
<ul>
<li><strong>大语言模型推理</strong>：降低KV-cache访问开销</li>
<li><strong>推荐系统</strong>：embedding查找加速</li>
<li><strong>生物信息学</strong>：基因序列比对</li>
<li><strong>密码学计算</strong>：同态加密运算</li>
</ul>
<hr />
<h2 id="_2">本章小结</h2>
<p>近存储计算架构通过将计算能力集成到内存系统中，从根本上改变了传统的冯·诺依曼架构限制。关键要点：</p>
<ol>
<li><strong>架构创新</strong>：PIM/PND技术显著减少数据移动，提升能效比2-3倍</li>
<li><strong>商业实现</strong>：Samsung HBM-PIM和SK Hynix AiM已实现产品化</li>
<li><strong>编程挑战</strong>：需要新的编程模型、编译器和运行时支持</li>
<li><strong>一致性设计</strong>：软硬件协同解决内存一致性问题</li>
<li><strong>应用潜力</strong>：在AI推理、图计算等领域展现显著优势</li>
</ol>
<p>关键公式总结：</p>
<ul>
<li>能效提升：$E_{PIM} = E_{compute} + E_{local_access} &lt;&lt; E_{compute} + E_{remote_access}$</li>
<li>带宽利用：$BW_{effective} = BW_{internal} × U_{parallelism}$</li>
<li>性能模型：$Speedup = \frac{T_{traditional}}{T_{PIM}} = \frac{1}{(1-f) + \frac{f}{S_{PIM}}}$</li>
</ul>
<hr />
<h2 id="_3">练习题</h2>
<h3 id="_4">基础题</h3>
<ol>
<li><strong>PIM架构分类</strong>
描述真PIM和近数据处理（PND）的区别，并给出各自的优缺点。</li>
</ol>
<details>
<summary>提示</summary>
<p>考虑集成位置、制造工艺、灵活性等因素</p>
</details>
<details>
<summary>答案</summary>
<p>真PIM将计算单元直接集成在存储阵列中：</p>
<ul>
<li>优点：最小化数据移动、最高带宽利用</li>
<li>缺点：受DRAM工艺限制、计算能力有限、散热困难</li>
</ul>
<p>PND在内存控制器或基础逻辑层集成计算：</p>
<ul>
<li>优点：可用先进逻辑工艺、计算能力强、易于散热</li>
<li>缺点：仍有一定数据移动开销、成本较高</li>
</ul>
</details>
<ol start="2">
<li><strong>性能计算</strong>
假设一个矩阵乘法C = A × B，其中A、B、C都是1024×1024的FP16矩阵。计算：
a) 传统架构的数据移动量
b) PIM架构的数据移动量（假设权重驻留）
c) 能耗节省比例（假设数据移动功耗是计算的20倍）</li>
</ol>
<details>
<summary>提示</summary>
<p>考虑矩阵乘法的访问模式和数据复用</p>
</details>
<details>
<summary>答案</summary>
<p>a) 传统架构：</p>
<ul>
<li>读取A、B：2 × 1024² × 2 bytes = 4 MB</li>
<li>写入C：1024² × 2 bytes = 2 MB</li>
<li>总计：6 MB</li>
</ul>
<p>b) PIM架构（B驻留）：</p>
<ul>
<li>读取A：1024² × 2 bytes = 2 MB</li>
<li>写入C：1024² × 2 bytes = 2 MB</li>
<li>总计：4 MB（节省33%）</li>
</ul>
<p>c) 能耗计算：</p>
<ul>
<li>传统：E_compute + 20 × E_compute × (6MB/2MB) = 61 × E_compute</li>
<li>PIM：E_compute + 20 × E_compute × (4MB/2MB) = 41 × E_compute</li>
<li>节省：(61-41)/61 = 32.8%</li>
</ul>
</details>
<ol start="3">
<li><strong>SIMD宽度选择</strong>
解释为什么Samsung HBM-PIM选择16-wide SIMD而不是32-wide或8-wide。</li>
</ol>
<details>
<summary>提示</summary>
<p>考虑内存行缓冲器大小、面积功耗权衡</p>
</details>
<details>
<summary>答案</summary>
<p>16-wide SIMD选择理由：</p>
<ol>
<li>匹配2KB行缓冲器：16 × 128 bytes = 2KB</li>
<li>平衡计算与带宽：16 × FP16 × 1.2GHz = 38.4 GFLOPS/channel</li>
<li>面积效率：32-wide会使面积翻倍但性能提升有限</li>
<li>功耗约束：更宽的SIMD需要更复杂的互联和控制逻辑</li>
</ol>
</details>
<h3 id="_5">挑战题</h3>
<ol start="4">
<li><strong>一致性协议设计</strong>
设计一个简化的PIM系统一致性协议，支持CPU和多个PIM单元同时访问共享数据。要求：</li>
</ol>
<ul>
<li>最小化同步开销</li>
<li>支持原子操作</li>
<li>避免死锁</li>
</ul>
<details>
<summary>提示</summary>
<p>可以考虑基于版本或基于所有权的协议</p>
</details>
<details>
<summary>答案</summary>
<p>基于所有权的轻量级协议：</p>
<ol>
<li>
<p>数据分区：
   - 每个数据区域有唯一所有者（CPU或PIM）
   - 所有者可直接读写，其他需请求</p>
</li>
<li>
<p>所有权转移：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nx">Request_Ownership</span><span class="p">(</span><span class="kd">addr</span><span class="p">,</span><span class="w"> </span><span class="nx">requester</span><span class="p">):</span>
<span class="w">  </span><span class="nx">current_owner</span><span class="p">.</span><span class="nx">flush_cache</span><span class="p">(</span><span class="kd">addr</span><span class="p">)</span>
<span class="w">  </span><span class="nx">transfer_ownership</span><span class="p">(</span><span class="kd">addr</span><span class="p">,</span><span class="w"> </span><span class="nx">requester</span><span class="p">)</span>
<span class="w">  </span><span class="nx">invalidate_other_caches</span><span class="p">(</span><span class="kd">addr</span><span class="p">)</span>
</code></pre></div>

<ol start="3">
<li>
<p>原子操作：
   - 临时获取独占所有权
   - 执行操作
   - 释放所有权</p>
</li>
<li>
<p>死锁避免：
   - 按地址顺序请求
   - 超时机制
   - 优先级调度</p>
</li>
</ol>
</details>
<ol start="5">
<li><strong>编译器优化</strong>
给定以下代码，展示如何将其优化以在PIM上高效执行：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 稀疏矩阵向量乘法</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">row_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">row_ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</code></pre></div>

<details>
<summary>提示</summary>
<p>考虑数据布局、并行化策略、预取</p>
</details>
<details>
<summary>答案</summary>
<p>PIM优化版本：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 1. 数据布局优化</span>
<span class="c1"># 将x向量复制到各PIM单元本地</span>

<span class="c1"># 2. 工作负载均衡分配</span>
<span class="n">rows_per_pim</span> <span class="o">=</span> <span class="n">balance_rows_by_nnz</span><span class="p">(</span><span class="n">row_ptr</span><span class="p">,</span> <span class="n">num_pim_units</span><span class="p">)</span>

<span class="c1"># 3. PIM并行执行</span>
<span class="n">parallel_for</span> <span class="n">pim_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pim_units</span><span class="p">):</span>
    <span class="n">local_rows</span> <span class="o">=</span> <span class="n">rows_per_pim</span><span class="p">[</span><span class="n">pim_id</span><span class="p">]</span>
    <span class="c1"># 预取x向量元素</span>
    <span class="n">prefetch_x_elements</span><span class="p">(</span><span class="n">local_rows</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">)</span>

    <span class="c1"># 本地计算</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">local_rows</span><span class="p">:</span>
        <span class="n">local_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">row_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">row_ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">local_sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_local</span><span class="p">[</span><span class="n">col_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="n">y_local</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_sum</span>

    <span class="c1"># 结果写回</span>
    <span class="n">writeback_y_results</span><span class="p">(</span><span class="n">y_local</span><span class="p">)</span>
</code></pre></div>

<p>关键优化：</p>
<ul>
<li>按非零元素数量均衡负载</li>
<li>x向量元素本地缓存</li>
<li>消除随机访问</li>
<li>批量写回结果</li>
</ul>
</details>
<ol start="6">
<li><strong>应用场景分析</strong>
分析以下哪些应用最适合PIM加速，并说明原因：
a) 密集矩阵LU分解
b) 图的广度优先搜索
c) 快速傅里叶变换
d) K-means聚类</li>
</ol>
<details>
<summary>提示</summary>
<p>考虑计算密度、访问模式、数据复用率</p>
</details>
<details>
<summary>答案</summary>
<p>适合程度排序：b &gt; d &gt; a &gt; c</p>
<p>b) BFS - 最适合：</p>
<ul>
<li>不规则内存访问模式</li>
<li>低计算密度（访存受限）</li>
<li>PIM可大幅减少随机访问开销</li>
</ul>
<p>d) K-means - 适合：</p>
<ul>
<li>距离计算的数据并行性高</li>
<li>中等计算密度</li>
<li>适合SIMD加速</li>
</ul>
<p>a) LU分解 - 中等：</p>
<ul>
<li>需要复杂的数据依赖管理</li>
<li>部分操作（GEMM）适合PIM</li>
<li>关键路径上的串行依赖限制并行性</li>
</ul>
<p>c) FFT - 最不适合：</p>
<ul>
<li>复杂的蝶形运算模式</li>
<li>高数据复用率（cache友好）</li>
<li>位反转访问模式难以优化</li>
</ul>
</details>
<ol start="7">
<li><strong>性能建模</strong>
建立一个PIM系统的性能模型，考虑：</li>
</ol>
<ul>
<li>计算时间</li>
<li>数据传输时间</li>
<li>同步开销
给出加速比公式并分析关键影响因素。</li>
</ul>
<details>
<summary>提示</summary>
<p>使用Amdahl定律的扩展形式</p>
</details>
<details>
<summary>答案</summary>
<p>PIM性能模型：</p>
<div class="codehilite"><pre><span></span><code>T_total = T_host + T_pim + T_sync

其中：
T_host = (1-f) × T_original
T_pim = f × T_original / (S_compute × U_bandwidth)
T_sync = N_sync × L_sync

加速比：
Speedup = T_original / T_total
        = 1 / ((1-f) + f/(S×U) + N_sync×L_sync/T_original)

关键参数：
f: 可并行化比例
S: PIM计算加速比
U: 带宽利用率
N_sync: 同步次数
L_sync: 同步延迟
</code></pre></div>

<p>影响因素分析：</p>
<ol>
<li>f越大，潜在加速越高</li>
<li>U受访问模式影响（随机访问U低）</li>
<li>N_sync×L_sync需要最小化</li>
<li>S受PIM计算能力限制</li>
</ol>
<p>临界点分析：
当 f/(S×U) + N_sync×L_sync/T_original &gt; f 时，PIM反而变慢</p>
</details>
<ol start="8">
<li><strong>未来架构设想</strong>
设计一个理想的下一代PIM架构，包括：</li>
</ol>
<ul>
<li>计算单元类型</li>
<li>内存组织</li>
<li>互联网络</li>
<li>编程模型
并分析实现挑战。</li>
</ul>
<details>
<summary>提示</summary>
<p>考虑可重构性、异构计算、新型存储器</p>
</details>
<details>
<summary>答案</summary>
<p>下一代PIM架构设想：</p>
<ol>
<li>
<p><strong>异构计算单元</strong>：
   - RISC-V通用核心（控制流）
   - 可重构数据流引擎（规则计算）
   - 专用加速器（AI、加密）</p>
</li>
<li>
<p><strong>分层内存组织</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">L1</span><span class="o">:</span><span class="w"> </span><span class="n">SRAM缓存</span><span class="w"> </span><span class="o">(</span><span class="err">每个</span><span class="n">PIM单元</span><span class="o">)</span>
<span class="n">L2</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="n">D堆叠DRAM</span><span class="w"> </span><span class="o">(</span><span class="err">高带宽</span><span class="o">)</span>
<span class="n">L3</span><span class="o">:</span><span class="w"> </span><span class="err">新型</span><span class="n">NVM</span><span class="w"> </span><span class="o">(</span><span class="err">大容量持久化</span><span class="o">)</span>
</code></pre></div>

<ol start="3">
<li>
<p><strong>可编程互联</strong>：
   - 片上网络（NoC）连接PIM单元
   - 动态可重构拓扑
   - 支持广播、归约等集合通信</p>
</li>
<li>
<p><strong>统一编程模型</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="err">@</span><span class="n">pim_kernel</span>
<span class="n">def</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="cp"># 自动分区和映射</span>
<span class="w">    </span><span class="n">with</span><span class="w"> </span><span class="n">pim</span><span class="p">.</span><span class="n">parallel</span><span class="p">()</span><span class="o">:</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pim</span><span class="p">.</span><span class="n">map_reduce</span><span class="p">(</span>
<span class="w">            </span><span class="n">mapper</span><span class="o">=</span><span class="n">custom_op</span><span class="p">,</span>
<span class="w">            </span><span class="n">reducer</span><span class="o">=</span><span class="n">sum</span><span class="p">,</span>
<span class="w">            </span><span class="n">data</span><span class="o">=</span><span class="n">data</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span>
</code></pre></div>

<p>实现挑战：</p>
<ul>
<li>工艺集成：逻辑与存储工艺不兼容</li>
<li>热管理：3D堆叠的散热问题</li>
<li>软件复杂性：需要全新的编译器和运行时</li>
<li>标准化：缺乏工业标准</li>
<li>成本：研发和制造成本高</li>
</ul>
</details>
<hr />
<h2 id="_6">常见陷阱与错误</h2>
<h3 id="_7">设计陷阱</h3>
<ol>
<li>
<p><strong>过度优化计算能力</strong>
   - 错误：追求高FLOPS而忽视内存带宽匹配
   - 正确：平衡计算与访存能力</p>
</li>
<li>
<p><strong>忽视热设计</strong>
   - 错误：在有限空间堆叠过多计算单元
   - 正确：考虑功耗密度和散热路径</p>
</li>
<li>
<p><strong>一致性过度设计</strong>
   - 错误：实现复杂的硬件一致性协议
   - 正确：采用软件管理的轻量级协议</p>
</li>
</ol>
<h3 id="_8">编程陷阱</h3>
<ol start="4">
<li>
<p><strong>不当的数据布局</strong>
   - 错误：沿用传统的行/列主序
   - 正确：按PIM单元分区的布局</p>
</li>
<li>
<p><strong>频繁同步</strong>
   - 错误：细粒度同步导致开销过大
   - 正确：批量操作减少同步次数</p>
</li>
<li>
<p><strong>忽视负载均衡</strong>
   - 错误：简单的静态分区
   - 正确：基于工作量的动态均衡</p>
</li>
</ol>
<h3 id="_9">性能陷阱</h3>
<ol start="7">
<li>
<p><strong>错误的性能预期</strong>
   - 错误：期望所有应用都能加速
   - 正确：识别适合PIM的应用特征</p>
</li>
<li>
<p><strong>忽视数据传输开销</strong>
   - 错误：只考虑计算时间
   - 正确：包含初始化和结果回传时间</p>
</li>
</ol>
<hr />
<h2 id="_10">最佳实践检查清单</h2>
<h3 id="_11">架构设计审查</h3>
<ul>
<li>[ ] 计算单元与内存带宽是否匹配？</li>
<li>[ ] 是否考虑了功耗和热约束？</li>
<li>[ ] 支持的数据类型是否满足目标应用？</li>
<li>[ ] 是否提供了灵活的内存访问模式？</li>
<li>[ ] 一致性模型是否简洁高效？</li>
</ul>
<h3 id="_12">软件栈评估</h3>
<ul>
<li>[ ] 编程模型是否易于使用？</li>
<li>[ ] 编译器能否自动优化数据布局？</li>
<li>[ ] 运行时是否支持动态负载均衡？</li>
<li>[ ] 调试和性能分析工具是否完善？</li>
<li>[ ] 是否与现有框架（TensorFlow/PyTorch）集成？</li>
</ul>
<h3 id="_13">应用适配性分析</h3>
<ul>
<li>[ ] 应用的计算密度是否较低（&lt;1 FLOP/byte）？</li>
<li>[ ] 是否存在大量不规则内存访问？</li>
<li>[ ] 数据并行性是否充足？</li>
<li>[ ] 工作集是否能装入PIM本地存储？</li>
<li>[ ] 同步需求是否较少？</li>
</ul>
<h3 id="_14">性能优化要点</h3>
<ul>
<li>[ ] 是否最大化了数据局部性？</li>
<li>[ ] 是否最小化了主存-PIM数据传输？</li>
<li>[ ] 是否合理分配了计算任务？</li>
<li>[ ] 是否优化了内存访问模式？</li>
<li>[ ] 是否减少了不必要的同步？</li>
</ul>
<h3 id="_15">部署就绪检查</h3>
<ul>
<li>[ ] 功耗预算是否满足系统要求？</li>
<li>[ ] 成本效益分析是否合理？</li>
<li>[ ] 是否有明确的性能提升目标？</li>
<li>[ ] 软件迁移路径是否清晰？</li>
<li>[ ] 是否制定了风险缓解计划？</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter14.html" class="nav-link prev">← 第14章：HBM编程模型与软件栈</a><a href="chapter16.html" class="nav-link next">第16章：CXL与内存扩展 →</a></nav>
        </main>
    </div>
</body>
</html>